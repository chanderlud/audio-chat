// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'contact.dart';
import 'error.dart';
import 'overlay/overlay.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `_start_session`, `bytes`, `calculate_rms`, `call_controller`, `call`, `db_to_multiplier`, `get_input_device`, `get_output_device`, `handshake`, `input_processor`, `latencies_missing`, `level_from_window`, `load`, `load`, `loopback`, `mul`, `new`, `new`, `new`, `new`, `new`, `open_stream`, `output_processor`, `read_message`, `relayed_only`, `resampler_factory`, `session_manager`, `session`, `silence`, `slice`, `socket_input`, `socket_output`, `statistics_collector`, `write_message`
// These types are ignored because they are not used by any `pub` functions: `CachedAtomicFlag`, `CachedAtomicFloat`, `ConnectionState`, `PeerState`, `ProcessorMessage`, `SendStream`, `SessionState`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `default`, `fmt`, `fmt`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Arc < Host >>>
abstract class ArcHost implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioChat>>
abstract class AudioChat implements RustOpaqueInterface {
  /// Blocks while an audio test is running
  Future<void> audioTest();

  Future<ChatMessage> buildChat(
      {required Contact contact, required String text});

  /// Ends the call (if there is one)
  void endCall();

  /// Lists the input and output devices
  Future<(List<String>, List<String>)> listDevices();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<AudioChat> newInstance(
          {required List<int> identity,
          required ArcHost host,
          required NetworkConfig networkConfig,
          required Overlay overlay,
          required FutureOr<bool> Function(String, Uint8List?, DartNotify)
              acceptCall,
          required FutureOr<void> Function(String, bool) callEnded,
          required FutureOr<Contact?> Function(Uint8List) getContact,
          required FutureOr<void> Function() connected,
          required FutureOr<void> Function(bool) callState,
          required FutureOr<void> Function(String, String) sessionStatus,
          required FutureOr<void> Function(AudioChat) startSessions,
          required FutureOr<Uint8List?> Function() loadRingtone,
          required FutureOr<void> Function(Statistics) statistics,
          required FutureOr<void> Function(ChatMessage) messageReceived,
          required FutureOr<void> Function(bool, bool) managerActive,
          required FutureOr<void> Function(Contact) callStarted}) =>
      RustLib.instance.api.crateApiAudioChatAudioChatNew(
          identity: identity,
          host: host,
          networkConfig: networkConfig,
          overlay: overlay,
          acceptCall: acceptCall,
          callEnded: callEnded,
          getContact: getContact,
          connected: connected,
          callState: callState,
          sessionStatus: sessionStatus,
          startSessions: startSessions,
          loadRingtone: loadRingtone,
          statistics: statistics,
          messageReceived: messageReceived,
          managerActive: managerActive,
          callStarted: callStarted);

  /// Restarts the session manager
  Future<void> restartManager();

  /// Attempts to start a call through an existing session
  Future<void> sayHello({required Contact contact});

  /// Sends a chat message
  Future<void> sendChat({required ChatMessage message});

  void setDeafened({required bool deafened});

  /// Changing the denoise flag will not affect the current call
  void setDenoise({required bool denoise});

  /// Sets the signing key (called when the profile changes)
  Future<void> setIdentity({required List<int> key});

  Future<void> setInputDevice({String? device});

  void setInputVolume({required double decibel});

  Future<void> setModel({required List<int> model});

  void setMuted({required bool muted});

  Future<void> setOutputDevice({String? device});

  void setOutputVolume({required double decibel});

  void setPlayCustomRingtones({required bool play});

  void setRmsThreshold({required double decimal});

  /// Tries to start a session for a contact
  Future<void> startSession({required Contact contact});

  /// Stops a specific session (called when a contact is deleted)
  Future<void> stopSession({required Contact contact});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChatMessage>>
abstract class ChatMessage implements RustOpaqueInterface {
  String get text;

  void set text(String text);

  bool isSender({required String identity});

  String time();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartNotify>>
abstract class DartNotify implements RustOpaqueInterface {
  /// public notified function for dart
  Future<void> notified();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkConfig>>
abstract class NetworkConfig implements RustOpaqueInterface {
  Future<String> getRelayAddress();

  Future<String> getRelayId();

  factory NetworkConfig(
          {required String relayAddress, required String relayId}) =>
      RustLib.instance.api.crateApiAudioChatNetworkConfigNew(
          relayAddress: relayAddress, relayId: relayId);

  Future<void> setRelayAddress({required String relayAddress});

  Future<void> setRelayId({required String relayId});
}

/// processed statistics for the frontend
class Statistics {
  /// a percentage of the max input volume in the window
  final double inputLevel;

  /// a percentage of the max output volume in the window
  final double outputLevel;

  /// the current call latency
  final BigInt latency;

  /// the approximate upload bandwidth used by the current call
  final BigInt uploadBandwidth;

  /// the approximate download bandwidth used by the current call
  final BigInt downloadBandwidth;

  /// a value between 0 and 1 representing the percent of audio lost in a sliding window
  final double loss;

  const Statistics({
    required this.inputLevel,
    required this.outputLevel,
    required this.latency,
    required this.uploadBandwidth,
    required this.downloadBandwidth,
    required this.loss,
  });

  @override
  int get hashCode =>
      inputLevel.hashCode ^
      outputLevel.hashCode ^
      latency.hashCode ^
      uploadBandwidth.hashCode ^
      downloadBandwidth.hashCode ^
      loss.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Statistics &&
          runtimeType == other.runtimeType &&
          inputLevel == other.inputLevel &&
          outputLevel == other.outputLevel &&
          latency == other.latency &&
          uploadBandwidth == other.uploadBandwidth &&
          downloadBandwidth == other.downloadBandwidth &&
          loss == other.loss;
}
